#ifndef MAP_UTILS_HPP
#define MAP_UTILS_HPP


namespace ft
{
	// template <class _T1, class _T2>
	// class pair
	// {
	// 	typedef _T1 first_type;
	// 	typedef _T2 second_type;

	// 	_T1 first;
	// 	_T2 second;

	// 	pair() : first(), second() {}

	// 	pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}

	// 	template <class _U1, class _U2>
	// 	pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

	// 	pair& operator=(pair const& __p) {
	// 		first = __p.first;
	// 		second = __p.second;
	// 		return *this;
	// 	}
	// };

	// template< class T1, class T2 >
	// ft::pair<T1, T2> make_pair( T1 t, T2 u )
	// {
	// 	return ft::pair<T1, T2>(t, u);
	// }

	// template< class T1, class T2, class U1, class U2 >
	// bool operator==( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	return (lhs.first && rhs.first && lhs.second && rhs.second);
	// }
	
	// template< class T1, class T2, class U1, class U2 >
	// bool operator!=( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	return (!(lhs == rhs));
	// }

	// template< class T1, class T2, class U1, class U2 >
	// bool operator<( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	if (lhs.first == rhs.first)
	// 		return (lhs.second < rhs.second);
	// 	return (lhs.first < rhs.first);
	// }

	// template< class T1, class T2, class U1, class U2 >
	// bool operator<=( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	return (!(rhs < lhs));
	// }

	// template< class T1, class T2, class U1, class U2 >
	// bool operator>( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	return (rhs < lhs);
	// }

	// template< class T1, class T2, class U1, class U2 >
	// bool operator>=( const std::pair<T1, T2>& lhs, const std::pair<U1, U2>& rhs)
	// {
	// 	return (!(lhs < rhs));
	// }	



}
#endif
